//+------------------------------------------------------------------+
//| grid_scalper.mq5 |
//| Copyright 2025,  Algorithmic Engineer |
//| https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Algorithmic Engineer"
#property link      "https://www.mql5.com"
#property version   "2.01"
#property strict
#property description "Advanced Grid Scalper with RSI logic, Dynamic Spacing, and Weighted Averaging"

//--- Standard Libraries
#include <Trade\Trade.mqh>
#include <Trade\SymbolInfo.mqh>
#include <Trade\PositionInfo.mqh>
#include <Trade\AccountInfo.mqh>

//--- Enums
enum ENUM_TP_TYPE {
   TP_AVERAGE,    // Average (Basket Close)
   TP_INDIVIDUAL  // Individual (Scalping)
};

enum ENUM_TRADE_DIR {
   DIR_BOTH,      // Both Directions
   DIR_BUY,       // Only Buy
   DIR_SELL       // Only Sell
};

enum ENUM_START_MODE {
   START_SIGNAL,     // Wait for RSI/MA
   START_IMMEDIATE   // Start Immediately
};

//--- Input Parameters
input group "=== [1] Identity & Risk ==="
input string      StrategyTag                = "GoldScalper";        // Strategy Name (Comment Tag)
input long        MagicNumber                = 123456;               // Unique Magic Number
input double      MaxDDToHedge               = 2000.0;               // Max Drawdown ($) -> Trigger Protection
input bool        CloseOnMaxDD               = true;                 // Close All if MaxDD Reached?
input bool        IncludeManualTrade         = false;                // Manage Manual Trades? (Magic 0)

input group "=== [2] Grid Execution ==="
input ENUM_TRADE_DIR Trade_Direction         = DIR_BOTH;             // Allowed Trade Direction
input ENUM_START_MODE StartMode              = START_IMMEDIATE;      // Entry Mode (Signal vs Immediate)
input string      LotSequence                = "0.01,0.01,0.01,0.02,0.02,0.03,0.04,0.06,0.10,0.15,0.25"; // Lot Sequence (Comma Separated)
input int         MaxOrders                  = 12;                   // Max Grid Orders (Per Side)
input double      GridDistance               = 400;                  // Grid Distance (Points)
input double      AddToDistance              = 200;                  // Step Increment (Points)
input int         IncreaseDistAfter          = 3;                    // Increase Distance after Order #

input group "=== [3] Profit & Exit ==="
input ENUM_TP_TYPE TP_Type                   = TP_AVERAGE;           // Take Profit Logic
input double      TakeProfit                 = 1000;                 // Profit Target (Points)
input bool        UseTrailing                = true;                 // Enable Trailing Stop
input double      ProfitToStartTrail         = 30.0;                 // Basket Profit to Start Trailing ($)
input double      TrailStartPoints           = 500;                  // Trail Start (Points)
input double      TrailStepPoints            = 100;                  // Trail Step (Points)
input bool        TrailOnlyLast              = true;                 // Trail Only Last Order?
input bool        UseStopLoss                = false;                // Enable Loss Limit?
input int         FixedStopLoss              = 5000;                 // Loss Limit (Points)

input group "=== [4] Entry Filters (Optional) ==="
input int         CooldownSeconds            = 300;                  // Cooldown after Basket Close (Sec)
input bool        ApplyTimeFilter            = false;                // Enable Time Filter
input string      StartTime                  = "08:00";              // Start Time (Server)
input string      StopTime                   = "20:00";              // Stop Time (Server)

input group "=== [5] Trend & Signal (If Signal Mode) ==="
input bool        UseTrendFilter             = true;                 // Enable Trend Filter (MA)
input int         MA_Period                  = 50;                   // MA Period
input int         RSI_Period                 = 14;                   // RSI Period
input double      RSI_Buy_Dip                = 30.0;                 // Buy: Reversal Level (Oversold)
input double      RSI_Buy_Trend              = 45.0;                 // Buy: Trend Dip Level
input double      RSI_Sell_Peak              = 70.0;                 // Sell: Reversal Level (Overbought)
input double      RSI_Sell_Trend             = 55.0;                 // Sell: Trend Rally Level

input group "=== [6] Range Trading Filters ==="
input bool        UseBuyRange                = false;                // Enable Buy Price Range?
input double      BuyStartPrice              = 1900.0;               // Buy: Start Price (Lower Bound)
input double      BuyStopPrice               = 2100.0;               // Buy: Stop Price (Upper Bound)
input bool        UseSellRange               = false;                // Enable Sell Price Range?
input double      SellStartPrice             = 2100.0;               // Sell: Start Price (Upper Bound)
input double      SellStopPrice              = 1900.0;               // Sell: Stop Price (Lower Bound)

//--- Global Objects
CTrade         m_trade;
CSymbolInfo    m_symbol;
CPositionInfo  m_position;
CAccountInfo   m_account;

//--- Global Variables
double         m_lot_array[];
int            m_rsi_handle;
double         m_rsi_buffer[];
bool           m_dd_breached = false;
int            m_ma_handle;
double         m_ma_buffer[];
datetime       m_last_close_time = 0;

//+------------------------------------------------------------------+
//| Expert initialization function |
//+------------------------------------------------------------------+
int OnInit()
{
   // 1. Initialize Symbol
   if(!m_symbol.Name(Symbol())) {
      Print("Failed to initialize symbol");
      return(INIT_FAILED);
   }
   RefreshRates();

   // 2. Parse Lot Array
   if(!ParseLotString(LotSequence, m_lot_array)) {
      Print("CRITICAL ERROR: Invalid LotSequence format.");
      return(INIT_PARAMETERS_INCORRECT);
   }

   // 3. Initialize Indicators
   m_rsi_handle = iRSI(Symbol(), Period(), RSI_Period, PRICE_CLOSE);
   if(m_rsi_handle == INVALID_HANDLE) {
      Print("Failed to create RSI indicator handle");
      return(INIT_FAILED);
   }
   ArraySetAsSeries(m_rsi_buffer, true);
   
   // 4. Initialize MA
   if(UseTrendFilter) {
      m_ma_handle = iMA(Symbol(), Period(), MA_Period, 0, MODE_EMA, PRICE_CLOSE);
      if(m_ma_handle == INVALID_HANDLE) {
         Print("Failed to create MA handle");
         return(INIT_FAILED);
      }
      ArraySetAsSeries(m_ma_buffer, true);
   }

   // 5. Setup Trade Object
   m_trade.SetExpertMagicNumber(MagicNumber);
   m_trade.SetMarginMode();
   m_trade.SetDeviationInPoints(10); // Price slippage tolerance in points

   PrintFormat("Grid Scalper v2.01 Initialized. Magic: %d", MagicNumber);
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   IndicatorRelease(m_rsi_handle);
   if(UseTrendFilter) IndicatorRelease(m_ma_handle);
}

//+------------------------------------------------------------------+
//| Expert tick function |
//+------------------------------------------------------------------+
void OnTick()
{
   if(!RefreshRates()) return;

   CheckEquityProtection();

   // --- 2. Grid Management ---
   ManageDirection(POSITION_TYPE_BUY);
   ManageDirection(POSITION_TYPE_SELL);

   // --- 3. Protection & Display ---
   if(UseTrailing) ManageTrailing();
   DisplayStatus();
}

//+------------------------------------------------------------------+
//| Main Directional Manager |
//+------------------------------------------------------------------+
void ManageDirection(ENUM_POSITION_TYPE type)
{
   int count = CountPositions(type);
   
   // A. If No Positions -> Check Entry Signal
   if(count == 0) {
      // Only enter if trading is allowed by time and DD is safe
      if(!m_dd_breached && IsTradingTime()) {
         
         // Cooldown Check
         if(TimeCurrent() - m_last_close_time < CooldownSeconds) return;

          bool signal = false;
          
          if(StartMode == START_IMMEDIATE) {
             // Immediate Mode: Check Direction
             if(type == POSITION_TYPE_BUY && (Trade_Direction == DIR_BUY || Trade_Direction == DIR_BOTH)) signal = true;
             if(type == POSITION_TYPE_SELL && (Trade_Direction == DIR_SELL || Trade_Direction == DIR_BOTH)) signal = true;
          } else {
             // Signal Mode
             signal = CheckEntrySignal(type);
          }
          
          if(signal) {
             // Range Filter Check
             if(!IsWithinRange(type, (type == POSITION_TYPE_BUY ? m_symbol.Ask() : m_symbol.Bid()))) signal = false;
          }

          if(signal) OpenFirstTrade(type);
      }
   }
   else {
      if(!m_dd_breached && count < MaxOrders) CheckGridExpansion(type, count);
      
      if(TP_Type == TP_AVERAGE) UpdateAverageTP(type);
   }
}

//+------------------------------------------------------------------+
//| Check Entry Signal (RSI) |
//+------------------------------------------------------------------+
bool CheckEntrySignal(ENUM_POSITION_TYPE type)
{
   // Direction Filter
   if(type == POSITION_TYPE_BUY && Trade_Direction == DIR_SELL) return false;
   if(type == POSITION_TYPE_SELL && Trade_Direction == DIR_BUY) return false;

   // RSI Buffer
   if(CopyBuffer(m_rsi_handle, 0, 0, 1, m_rsi_buffer) < 1) return false;
   double rsi = m_rsi_buffer[0];

   // Trend Filter (Dual Zone Logic)
   if(UseTrendFilter) {
      if(CopyBuffer(m_ma_handle, 0, 0, 1, m_ma_buffer) < 1) return false;
      double ma = m_ma_buffer[0];
      double close = iClose(Symbol(), Period(), 0);
      
      if(type == POSITION_TYPE_BUY) {
         // Zone A: Strong Uptrend (Price > MA) -> Buy Shallow Dips
         if(close > ma) {
            if(rsi < RSI_Buy_Trend) return true;
         } 
         // Zone B: Below MA -> Only Buy Deep Reversals
         else {
            if(rsi < RSI_Buy_Dip) return true;
         }
         return false; // No Buy Signal
      }
      
      if(type == POSITION_TYPE_SELL) {
         // Zone A: Strong Downtrend (Price < MA) -> Sell Shallow Rallies
         if(close < ma) {
            if(rsi > RSI_Sell_Trend) return true;
         }
         // Zone B: Above MA -> Only Sell Deep Reversals
         else {
             if(rsi > RSI_Sell_Peak) return true;
         }
         return false; // No Sell Signal
      }
   } else {
      // Standard RSI Logic if Filter OFF
      if(type == POSITION_TYPE_BUY) return (rsi < RSI_Buy_Dip);
      if(type == POSITION_TYPE_SELL) return (rsi > RSI_Sell_Peak);
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Open First Trade |
//+------------------------------------------------------------------+
void OpenFirstTrade(ENUM_POSITION_TYPE type)
{
   double lot = GetLotSize(0);
   double price = (type == POSITION_TYPE_BUY)? m_symbol.Ask() : m_symbol.Bid();
   double tp_price = 0;
      if(TP_Type == TP_INDIVIDUAL) {
       if(type == POSITION_TYPE_BUY) tp_price = price + TakeProfit * m_symbol.Point();
       else tp_price = price - TakeProfit * m_symbol.Point();
    } 
    
    if(type == POSITION_TYPE_BUY && tp_price == 0) tp_price = price + TakeProfit * m_symbol.Point();
    if(type == POSITION_TYPE_SELL && tp_price == 0) tp_price = price - TakeProfit * m_symbol.Point();

   tp_price = NormalizeDouble(tp_price, m_symbol.Digits());

   double sl_price = 0;
   if(UseStopLoss) {
      if(type == POSITION_TYPE_BUY) sl_price = price - FixedStopLoss * m_symbol.Point();
      else sl_price = price + FixedStopLoss * m_symbol.Point();
      sl_price = NormalizeDouble(sl_price, m_symbol.Digits());
   }

   if(type == POSITION_TYPE_BUY) {
      string comment = StringFormat("%s BUY #1 (%.2f)", StrategyTag, lot);
      m_trade.Buy(lot, Symbol(), price, sl_price, tp_price, comment);
   } else {
      string comment = StringFormat("%s SELL #1 (%.2f)", StrategyTag, lot);
      m_trade.Sell(lot, Symbol(), price, sl_price, tp_price, comment);
   }
}

//+------------------------------------------------------------------+
//| Check Grid Expansion |
//+------------------------------------------------------------------+
void CheckGridExpansion(ENUM_POSITION_TYPE type, int current_count)
{
   // Find "Worst" Price
   double worst_price = 0;
   
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
      if(m_position.SelectByIndex(i)) {
         if(IsMyPosition() && m_position.PositionType() == type) {
            if(type == POSITION_TYPE_BUY) {
               if(worst_price == 0 || m_position.PriceOpen() < worst_price) worst_price = m_position.PriceOpen();
            } else {
               if(worst_price == 0 || m_position.PriceOpen() > worst_price) worst_price = m_position.PriceOpen();
            }
         }
      }
   }
   
   // Calculate Required Distance
   double required_dist = GridDistance;
   if(current_count >= IncreaseDistAfter) {
      required_dist += AddToDistance;
   }
   
   // Check Distance
   bool trigger = false;
   if(type == POSITION_TYPE_BUY) {
      if(m_symbol.Ask() <= worst_price - required_dist * m_symbol.Point()) trigger = true;
   } else {
      if(m_symbol.Bid() >= worst_price + required_dist * m_symbol.Point()) trigger = true;
   }
   
   if(trigger) {
      double price = (type == POSITION_TYPE_BUY)? m_symbol.Ask() : m_symbol.Bid();
      
      // Range Filter Check for Grid Expansion
      if(!IsWithinRange(type, price)) return;

      double lot = GetLotSize(current_count);
      
      double tp = 0;
      if(TP_Type == TP_INDIVIDUAL) {
          if(type == POSITION_TYPE_BUY) tp = price + TakeProfit * m_symbol.Point();
          else tp = price - TakeProfit * m_symbol.Point();
      }
      
      double sl = 0;
      if(UseStopLoss) {
          if(type == POSITION_TYPE_BUY) sl = price - FixedStopLoss * m_symbol.Point();
          else sl = price + FixedStopLoss * m_symbol.Point();
          sl = NormalizeDouble(sl, m_symbol.Digits());
      }

      string typeStr = (type == POSITION_TYPE_BUY) ? "BUY" : "SELL";
      string comment = StringFormat("%s %s #%d (%.2f)", StrategyTag, typeStr, current_count + 1, lot);

      if(type == POSITION_TYPE_BUY) m_trade.Buy(lot, Symbol(), price, sl, tp, comment);
      else m_trade.Sell(lot, Symbol(), price, sl, tp, comment);
   }
}

//+------------------------------------------------------------------+
//| Update Average Take Profit |
//+------------------------------------------------------------------+
void UpdateAverageTP(ENUM_POSITION_TYPE type)
{
   double sum_prod = 0;
   double sum_vol = 0;
   
   // Calculate Weighted Average
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
      if(m_position.SelectByIndex(i)) {
         if(IsMyPosition() && m_position.PositionType() == type) {
            sum_prod += m_position.PriceOpen() * m_position.Volume();
            sum_vol += m_position.Volume();
         }
      }
   }
   
   if(sum_vol == 0) return;
   
   double avg_price = sum_prod / sum_vol;
   double new_tp = 0;
   
   if(type == POSITION_TYPE_BUY) new_tp = avg_price + TakeProfit * m_symbol.Point();
   else new_tp = avg_price - TakeProfit * m_symbol.Point();
   
   new_tp = NormalizeDouble(new_tp, m_symbol.Digits());
   
   // Apply to all positions
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
      if(m_position.SelectByIndex(i)) {
         if(IsMyPosition() && m_position.PositionType() == type) {
            // Only modify if different to save bandwidth
            if(MathAbs(m_position.TakeProfit() - new_tp) > m_symbol.Point()) {
               if(m_trade.PositionModify(m_position.Ticket(), m_position.StopLoss(), new_tp)) {
                  PrintFormat("Profit Target UPDATED: [%s] Ticket #%I64u set to %.2f", (type==POSITION_TYPE_BUY?"BUY":"SELL"), m_position.Ticket(), new_tp);
               }
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Manage Trailing Stop |
//+------------------------------------------------------------------+
void ManageTrailing()
{
   // 1. Calculate Floating Profit per direction
   double profit_buy = 0, profit_sell = 0;
   
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
       if(m_position.SelectByIndex(i) && IsMyPosition()) {
           if(m_position.PositionType() == POSITION_TYPE_BUY) profit_buy += m_position.Profit() + m_position.Swap() + m_position.Commission();
           if(m_position.PositionType() == POSITION_TYPE_SELL) profit_sell += m_position.Profit() + m_position.Swap() + m_position.Commission();
       }
   }
   
   // 2. Identify Last Ticket (if LastTradeTrailing enabled)
   ulong last_buy_ticket = 0;
   ulong last_sell_ticket = 0;
   if(TrailOnlyLast) {
       last_buy_ticket = GetLastTicket(POSITION_TYPE_BUY);
       last_sell_ticket = GetLastTicket(POSITION_TYPE_SELL);
   }

   // 3. Apply Trailing
   // Logic: If Basket Profit > ProfitInAmountTrailStart, apply Points Trailing to valid orders
   
   if(profit_buy >= ProfitToStartTrail) ApplyTrail(POSITION_TYPE_BUY, last_buy_ticket);
   if(profit_sell >= ProfitToStartTrail) ApplyTrail(POSITION_TYPE_SELL, last_sell_ticket);
}

void ApplyTrail(ENUM_POSITION_TYPE type, ulong last_ticket)
{
    double point = m_symbol.Point();
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
       if(m_position.SelectByIndex(i) && IsMyPosition() && m_position.PositionType() == type) {
           
           if(TrailOnlyLast && m_position.Ticket()!= last_ticket) continue;
           
           double new_sl = 0;
           double price = (type == POSITION_TYPE_BUY)? m_symbol.Bid() : m_symbol.Ask();
           
           if(type == POSITION_TYPE_BUY) {
               // Price must be above Open + StartTrailing
               if(price > m_position.PriceOpen() + TrailStartPoints * point) {
                   double proposed = price - TrailStepPoints * point;
                   if(proposed > m_position.PriceOpen() && proposed > m_position.StopLoss()) new_sl = proposed;
               }
           } else {
               if(price < m_position.PriceOpen() - TrailStartPoints * point) {
                   double proposed = price + TrailStepPoints * point;
                   if(proposed < m_position.PriceOpen() && (m_position.StopLoss() == 0 || proposed < m_position.StopLoss())) new_sl = proposed;
               }
           }
           
           if(new_sl!= 0) {
               new_sl = NormalizeDouble(new_sl, m_symbol.Digits());
               m_trade.PositionModify(m_position.Ticket(), new_sl, m_position.TakeProfit());
           }
       }
    }
}

//+------------------------------------------------------------------+
//| Safety Check & Helpers |
//+------------------------------------------------------------------+
void CheckEquityProtection()
{
   double current_dd = m_account.Balance() - m_account.Equity();
   if(current_dd > MaxDDToHedge) {
       if(!m_dd_breached) PrintFormat("Max Drawdown Reached! Current DD: %.2f", current_dd);
       
       if(CloseOnMaxDD) {
          Print("Emergency Protection: Closing ALL Positions.");
          CloseAll();
       }
       m_dd_breached = true;
   } else {
       m_dd_breached = false; 
   }
}

//+------------------------------------------------------------------+
//| Helpers |
//+------------------------------------------------------------------+
bool IsMyPosition() {
   if(m_position.Symbol()!= Symbol()) return false;
   if(m_position.Magic() == MagicNumber) return true;
   if(IncludeManualTrade && m_position.Magic() == 0) return true;
   return false;
}

int CountPositions(ENUM_POSITION_TYPE type) {
   int cnt = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
      if(m_position.SelectByIndex(i) && IsMyPosition() && m_position.PositionType() == type) cnt++;
   }
   return cnt;
}

bool IsWithinRange(ENUM_POSITION_TYPE type, double price)
{
   if(type == POSITION_TYPE_BUY && UseBuyRange) {
      // For Buy: Start is usually lower, Stop is upper.
      // But we just check if price is between min and max for simplicity
      double min_p = MathMin(BuyStartPrice, BuyStopPrice);
      double max_p = MathMax(BuyStartPrice, BuyStopPrice);
      if(price < min_p || price > max_p) return false;
   }
   
   if(type == POSITION_TYPE_SELL && UseSellRange) {
      double min_p = MathMin(SellStartPrice, SellStopPrice);
      double max_p = MathMax(SellStartPrice, SellStopPrice);
      if(price < min_p || price > max_p) return false;
   }
   
   return true;
}

void DisplayStatus()
{
   double pBuy = 0, pSell = 0, vBuy = 0, vSell = 0;
   int cBuy = 0, cSell = 0;
   
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
      if(m_position.SelectByIndex(i) && IsMyPosition()) {
         if(m_position.PositionType() == POSITION_TYPE_BUY) {
            pBuy += m_position.Profit() + m_position.Swap() + m_position.Commission();
            vBuy += m_position.Volume();
            cBuy++;
         } else {
            pSell += m_position.Profit() + m_position.Swap() + m_position.Commission();
            vSell += m_position.Volume();
            cSell++;
         }
      }
   }
   
   string text = "--- [ " + StrategyTag + " ] ---\n";
   text += StringFormat(" Magic: %d | Acc: %d\n", MagicNumber, m_account.Login());
   text += "---------------------------------\n";
   text += StringFormat(" BUY:  %d Orders | %.2f Lots\n", cBuy, vBuy);
   text += StringFormat("       Profit: %.2f\n", pBuy);
   text += "---------------------------------\n";
   text += StringFormat(" SELL: %d Orders | %.2f Lots\n", cSell, vSell);
   text += StringFormat("       Profit: %.2f\n", pSell);
   text += "---------------------------------\n";
   text += StringFormat(" TOTAL PROFIT: %.2f\n", pBuy + pSell);
   text += StringFormat(" TOTAL LOTS:   %.2f\n", vBuy + vSell);
   
   if(m_dd_breached) text += " !!! DD PROTECTION ACTIVE !!!\n";
   text += "---------------------------------";
   
   Comment(text);
}

double GetLotSize(int index) {
   if(index >= ArraySize(m_lot_array)) return m_lot_array[ArraySize(m_lot_array)-1];
   return m_lot_array[index];
}

bool ParseLotString(string str_in, double& result[]) {
   string sep = ",";
   ushort u_sep = StringGetCharacter(sep, 0);
   string parts[];
   int total = StringSplit(str_in, u_sep, parts);
   if(total <= 0) return false;
   ArrayResize(result, total);
   for(int i=0; i<total; i++) result[i] = StringToDouble(parts[i]);
   return true;
}

bool RefreshRates() { return m_symbol.RefreshRates(); }

bool IsTradingTime() {
   if(!ApplyTimeFilter) return true;
   MqlDateTime dt;
   TimeToStruct(TimeCurrent(), dt);
   string curr = StringFormat("%02d:%02d", dt.hour, dt.min);
   if(StartTime < StopTime) return (curr >= StartTime && curr <= StopTime);
   return (curr >= StartTime || curr <= StopTime);
}

ulong GetLastTicket(ENUM_POSITION_TYPE type) {
    ulong ticket = 0;
    long time = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        if(m_position.SelectByIndex(i) && IsMyPosition() && m_position.PositionType() == type) {
            if(m_position.Time() > time) {
                time = m_position.Time();
                ticket = m_position.Ticket();
            }
        }
    }
    return ticket;
}

void CloseAll() {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        if(m_position.SelectByIndex(i) && IsMyPosition()) m_trade.PositionClose(m_position.Ticket());
    }
    m_last_close_time = TimeCurrent();
}
//+------------------------------------------------------------------+