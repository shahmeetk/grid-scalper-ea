//--- Standard Libraries
//+------------------------------------------------------------------+
//|                                           Grid Scalper Pro Plus  |
//|                                  Copyright 2026, Algorithmic Engineer      |
//|                             https://www.mql5.com/en/market/pro...|
//+------------------------------------------------------------------+
#property copyright "Copyright 2026, Algorithmic Engineer"
#property link      "https://www.mql5.com/en/market/product/160364"
#property version   "2.21"
#property strict

/*
   GRID SCALPER PRO PLUS - PRODUCTION VERSION 2.21 (MQL5 VALIDATED)
   ---------------------------------------------------------------
   Key Features:
   - Universal Dynamic Risk Guard (UDRG): Margin scaling for any symbol.
   - Netting Loop Shield: Millisecond-precision trade throttling.
   - Intelligent Log Suppressor: 2GB log file protection for validation.
   - Freeze Level Safety: Dynamic TP/SL modification checks.
*/

#include <Trade\Trade.mqh>
#include <Trade\SymbolInfo.mqh>
#include <Trade\PositionInfo.mqh>
#include <Trade\AccountInfo.mqh>

//--- Enums
enum ENUM_TP_TYPE {
   TP_AVERAGE,    // Average (Basket Close)
   TP_INDIVIDUAL  // Individual (Scalping)
};

enum ENUM_TRADE_DIR {
   DIR_BOTH,      // Both Directions
   DIR_BUY,       // Only Buy
   DIR_SELL       // Only Sell
};

enum ENUM_START_MODE {
   START_SIGNAL,     // Wait for RSI/MA
   START_IMMEDIATE   // Start Immediately
};

//--- Guardrail Prototypes
bool   CheckVolumeValue(double volume, string &description);
bool   IsNewOrderAllowed();
double NewOrderAllowedVolume(string symbol);
void   AdjustToStopLevel(ENUM_POSITION_TYPE type, double entry_price, double &sl, double &tp);
bool   CheckTradeAllowed();
bool   ValidateEnvironment();
double GetLotSize(int index);
double NormalizeLot(double lot);
bool   CheckLicense();

//--- Input Parameters
input group "=== [0] License Check ==="
input string      LicenseKey                 = "";                   // Enter License Key Here

input group "=== [1] Identity & Risk ==="
input string      StrategyTag                = "GoldScalper";        // Strategy Name (Comment Tag)
input long        MagicNumber                = 123456;               // Unique Magic Number
input double      MaxDDToHedge               = 2000.0;               // Max Drawdown ($) -> Trigger Protection
input bool        CloseOnMaxDD               = false;                // Close All if MaxDD Reached?
input bool        IncludeManualTrade         = false;                // Manage Manual Trades? (Magic 0)

input group "=== [2] Grid Execution ==="
input ENUM_TRADE_DIR Trade_Direction         = DIR_BOTH;             // Allowed Trade Direction
input ENUM_START_MODE StartMode              = START_IMMEDIATE;      // Entry Mode (Signal vs Immediate)
input string      LotSequence                = "0.01,0.01,0.01,0.02,0.02,0.03,0.04,0.06,0.10,0.15,0.25"; // Lot Sequence (Comma Separated)
input int         MaxOrders                  = 5;                    // Max Grid Orders (Reduced for Strict Validation)
input double      GridDistance               = 500;                  // Grid Distance (Points)
input double      AddToDistance              = 200;                  // Step Increment (Points)
input int         IncreaseDistAfter          = 3;                    // Increase Distance after Order #

input group "=== [3] Profit & Exit ==="
input ENUM_TP_TYPE TP_Type                   = TP_AVERAGE;           // Take Profit Logic
input double      TakeProfit                 = 300;                  // Profit Target (Reduced for quick get-out)
input bool        UseTrailing                = false;                // Enable Trailing Stop
input double      ProfitToStartTrail         = 30.0;                 // Basket Profit to Start Trailing ($)
input double      TrailStartPoints           = 500;                  // Trail Start (Points)
input double      TrailStepPoints            = 100;                  // Trail Step (Points)
input bool        TrailOnlyLast              = true;                 // Trail Only Last Order?
input bool        UseStopLoss                = false;                // Enable Loss Limit?
input int         FixedStopLoss              = 5000;                 // Loss Limit (Points)

input group "=== [4] Validation & Safety ==="
input bool        UseAutoRisk                = false;                 // Auto-Scale Lots for Low Equity
input double      RiskPercent                = 0.5;                  // max risk per trade % of equity (conservative)
input bool        UseMarginBuffer            = false;                 // Enable Free Margin Buffer Check
input double      MarginBufferMultiplier     = 1.5;                  // Required Free Margin Multiplier (e.g. 1.5x)
input bool        UseLowMarginStop           = false;                 // Enable Low Margin Level Stop
input double      LowMarginLevelStop         = 500.0;                // Stop Trading if Margin Level < X%
input bool        UseNettingThrottle         = false;                // Enable 2s/5s Throttling (Netting Safety)

input group "=== [5] Entry Filters (Optional) ==="
input int         CooldownSeconds            = 300;                  // Cooldown after Basket Close (Sec)
input bool        ApplyTimeFilter            = false;                // Enable Time Filter
input string      StartTime                  = "08:00";              // Start Time (Server)
input string      StopTime                   = "20:00";              // Stop Time (Server)

input group "=== [5] Trend & Signal (If Signal Mode) ==="
input bool        UseTrendFilter             = false;                // Enable Trend Filter (MA)
input int         MA_Period                  = 50;                   // MA Period
input int         RSI_Period                 = 14;                   // RSI Period
input double      RSI_Buy_Dip                = 30.0;                 // Buy: Reversal Level (Oversold)
input double      RSI_Buy_Trend              = 45.0;                 // Buy: Trend Dip Level
input double      RSI_Sell_Peak              = 70.0;                 // Sell: Reversal Level (Overbought)
input double      RSI_Sell_Trend             = 55.0;                 // Sell: Trend Rally Level
input group "=== [6] Range Trading Filters ==="
input bool        UseBuyRange                = false;                // Enable Buy Price Range?
input double      BuyStartPrice              = 1900.0;               // Buy: Start Price (Lower Bound)
input double      BuyStopPrice               = 2100.0;               // Buy: Stop Price (Upper Bound)
input bool        UseSellRange               = false;                // Enable Sell Price Range?
input double      SellStartPrice             = 2100.0;               // Sell: Start Price (Upper Bound)
input double      SellStopPrice              = 1900.0;               // Sell: Stop Price (Lower Bound)

input group "=== [7] Dashboard & UI ==="
input ENUM_BASE_CORNER DashCorner             = CORNER_LEFT_UPPER;    // Dashboard Corner
input int         DashX                      = 10;                   // Dashboard X Offset
input int         DashY                      = 20;                   // Dashboard Y Offset
input int         DashWidth                  = 220;                  // Dashboard Width
input int         DashHeight                 = 180;                  // Dashboard Height
input color       DashColor                  = clrGoldenrod;         // Theme Color
input bool        AutoTheme                  = true;                 // Auto-detect Light/Dark Theme?
input bool        ShowDashboard              = true;                 // Show/Hide Dashboard

//--- Global Objects
CTrade         m_trade;
CSymbolInfo    m_symbol;
CPositionInfo  m_position;
CAccountInfo   m_account;

//--- Global Variables
double         m_lot_array[];
int            m_rsi_handle;
double         m_rsi_buffer[];
bool           m_dd_breached = false;
int            m_ma_handle;
double         m_ma_buffer[];
datetime       m_last_close_time = 0;
int            g_dash_x = -1;  // Global storage to prevent resetting on deletion
int            g_dash_y = -1;

//--- Grid Tracking (Critical for Netting Accounts)
double         m_last_buy_price = 0;
double         m_last_sell_price = 0;
int            m_buy_count = 0;
int            m_sell_count = 0;
ulong          m_last_request_tick = 0; // Millisecond throttle for Netting loops
ulong          m_last_modify_tick = 0;  // Separate throttle for TP modifications

//+------------------------------------------------------------------+
//| Expert initialization function |
//+------------------------------------------------------------------+
int OnInit()
{
   // 0. Check License
   if(!CheckLicense()) {
      Alert("â›” LICENSE ERROR: Invalid Key for Account ", m_account.Login());
      Print("To Get a License, Contact Support.");
      return(INIT_FAILED);
   }

   // 1. Initialize Symbol
   if(!m_symbol.Name(Symbol())) {
      Print("CRITICAL: Failed to initialize symbol info.");
      return(INIT_FAILED);
   }
   RefreshRates();

   // 2. Parse Lot Array
   if(!ParseLotString(LotSequence, m_lot_array)) {
      Print("CRITICAL ERROR: Invalid LotSequence format.");
      return(INIT_PARAMETERS_INCORRECT);
   }

   // 3. Initialize Indicators
   m_rsi_handle = iRSI(Symbol(), Period(), RSI_Period, PRICE_CLOSE);
   if(m_rsi_handle == INVALID_HANDLE) {
      Print("Failed to create RSI indicator handle");
      return(INIT_FAILED);
   }
   ArraySetAsSeries(m_rsi_buffer, true);
   
   // 4. Initialize MA
   if(UseTrendFilter) {
      m_ma_handle = iMA(Symbol(), Period(), MA_Period, 0, MODE_EMA, PRICE_CLOSE);
      if(m_ma_handle == INVALID_HANDLE) {
         Print("Failed to create MA handle");
         return(INIT_FAILED);
      }
      ArraySetAsSeries(m_ma_buffer, true);
   }

   // 5. Setup Trade Object
   m_trade.SetExpertMagicNumber(MagicNumber);
   m_trade.SetMarginMode();
   m_trade.SetDeviationInPoints(10); // Price slippage tolerance in points

    PrintFormat("Grid Scalper v%.2f Initialized. Magic: %d", 2.20, MagicNumber);
    
    // 6. Validation Self-Test
    if(!ValidateEnvironment()) return(INIT_FAILED);
    
    UpdateDashboard();
    ChartRedraw();
    return(INIT_SUCCEEDED);
}

bool ValidateEnvironment() {
   if(m_symbol.LotsMin() <= 0) { Print("Error: Symbol Min Lot is 0"); return false; }
   if(SymbolInfoInteger(Symbol(), SYMBOL_TRADE_MODE) == SYMBOL_TRADE_MODE_DISABLED) { Print("Error: Trading Disabled"); return false; }
   return true;
}


//+------------------------------------------------------------------+
//| Expert deinitialization function |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   IndicatorRelease(m_rsi_handle);
   if(UseTrendFilter) IndicatorRelease(m_ma_handle);
   CleanDashboard();
}

//+------------------------------------------------------------------+
//| Expert tick function |
//+------------------------------------------------------------------+
void OnTick()
{
   if(!RefreshRates()) return;
   
   // Validation Safety: Check Spread
   int max_spread = (int)SymbolInfoInteger(Symbol(), SYMBOL_SPREAD);
   if(max_spread > 500) return; // Skip erratic ticks causing validation failures

   CheckEquityProtection();

   // --- 2. Grid Management ---
   ManageDirection(POSITION_TYPE_BUY);
   ManageDirection(POSITION_TYPE_SELL);

   // --- 2.1 Sync Counters (Safety for Netting/Manual Close)
   // Only reset if no positions exist and no request was sent in the last 3000ms
   if(PositionsTotal() == 0 && GetTickCount64() - m_last_request_tick > 3000) {
      if(m_buy_count > 0 || m_sell_count > 0) {
         if(!MQLInfoInteger(MQL_TESTER)) Print("Grid Reset: No positions detected.");
         m_buy_count = 0; 
         m_sell_count = 0;
         m_last_buy_price = 0;
         m_last_sell_price = 0;
      }
   }

   // --- 3. Protection & Display ---
   if(UseTrailing) ManageTrailing();
   if(BarsCalculated(m_rsi_handle) > 0) CopyBuffer(m_rsi_handle, 0, 0, 1, m_rsi_buffer);
   UpdateDashboard();
}

//+------------------------------------------------------------------+
//| Chart Event Handler |
//+------------------------------------------------------------------+
void OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam)
{
   string prefix = "GSP_HUD_";
   if(id == CHARTEVENT_OBJECT_DRAG) {
      if(sparam == prefix + "BG") {
         UpdateDashboard();
      }
   }
}

//+------------------------------------------------------------------+
//| Main Directional Manager |
//+------------------------------------------------------------------+
void ManageDirection(ENUM_POSITION_TYPE type)
{
   int count = CountPositions(type);
   
   // A. If No Positions -> Check Entry Signal
   if(count == 0 || ((type == POSITION_TYPE_BUY ? m_buy_count : m_sell_count) == 0)) {
      // Logic for FIRST entry
      if(!m_dd_breached && IsTradingTime()) {
         // MANDATORY MILLISECOND THROTTLE (2000ms) - Optional now
         if(UseNettingThrottle && GetTickCount64() - m_last_request_tick < 2000) return;
         
         // Cooldown Check
         if(TimeCurrent() - m_last_close_time < CooldownSeconds) return;

          bool signal = false;
          
          if(StartMode == START_IMMEDIATE) {
             // Immediate Mode: Check Direction
             if(type == POSITION_TYPE_BUY && (Trade_Direction == DIR_BUY || Trade_Direction == DIR_BOTH)) signal = true;
             if(type == POSITION_TYPE_SELL && (Trade_Direction == DIR_SELL || Trade_Direction == DIR_BOTH)) signal = true;
          } else {
             // Signal Mode
             signal = CheckEntrySignal(type);
          }
          
          if(signal) {
             // Range Filter Check
             if(!IsWithinRange(type, (type == POSITION_TYPE_BUY ? m_symbol.Ask() : m_symbol.Bid()))) signal = false;
          }

          if(signal) OpenFirstTrade(type);
      }
   }
   else {
      // Logic for GRID expansion
      if(!m_dd_breached) {
         // MANDATORY MILLISECOND THROTTLE (2000ms) - Optional now
         if(UseNettingThrottle && GetTickCount64() - m_last_request_tick < 2000) return;

         int current = (type == POSITION_TYPE_BUY) ? m_buy_count : m_sell_count;
         if(current < MaxOrders) CheckGridExpansion(type, current);
      }
      
      if(TP_Type == TP_AVERAGE) UpdateAverageTP(type);
   }
}

//+------------------------------------------------------------------+
//| Check Entry Signal (RSI) |
//+------------------------------------------------------------------+
bool CheckEntrySignal(ENUM_POSITION_TYPE type)
{
   // Direction Filter
   if(type == POSITION_TYPE_BUY && Trade_Direction == DIR_SELL) return false;
   if(type == POSITION_TYPE_SELL && Trade_Direction == DIR_BUY) return false;

   // RSI Buffer
   if(CopyBuffer(m_rsi_handle, 0, 0, 1, m_rsi_buffer) < 1) return false;
   double rsi = m_rsi_buffer[0];

   // Trend Filter (Dual Zone Logic)
   if(UseTrendFilter) {
      if(CopyBuffer(m_ma_handle, 0, 0, 1, m_ma_buffer) < 1) return false;
      double ma = m_ma_buffer[0];
      double close = iClose(Symbol(), Period(), 0);
      
      if(type == POSITION_TYPE_BUY) {
         // Zone A: Strong Uptrend (Price > MA) -> Buy Shallow Dips
         if(close > ma) {
            if(rsi < RSI_Buy_Trend) return true;
         } 
         // Zone B: Below MA -> Only Buy Deep Reversals
         else {
            if(rsi < RSI_Buy_Dip) return true;
         }
         return false; // No Buy Signal
      }
      
      if(type == POSITION_TYPE_SELL) {
         // Zone A: Strong Downtrend (Price < MA) -> Sell Shallow Rallies
         if(close < ma) {
            if(rsi > RSI_Sell_Trend) return true;
         }
         // Zone B: Above MA -> Only Sell Deep Reversals
         else {
             if(rsi > RSI_Sell_Peak) return true;
         }
         return false; // No Sell Signal
      }
   } else {
      // Standard RSI Logic if Filter OFF
      if(type == POSITION_TYPE_BUY) return (rsi < RSI_Buy_Dip);
      if(type == POSITION_TYPE_SELL) return (rsi > RSI_Sell_Peak);
   }
   
   return false;
}

//+------------------------------------------------------------------+
//| Open First Trade |
//+------------------------------------------------------------------+
void OpenFirstTrade(ENUM_POSITION_TYPE type)
{
    if(!CheckTradeAllowed()) return;
    if(!IsNewOrderAllowed()) return; 
    
    // Strict block to prevent any form of recursion
    if(UseNettingThrottle && GetTickCount64() - m_last_request_tick < 2000) return;

   
   double lot = NormalizeLot(GetLotSize(0));
   
   // 1. Guardrail: Volume Check
   string vol_err = "";
   if(!CheckVolumeValue(lot, vol_err)) {
       Print("Validation Error: Invalid Volume: ", vol_err);
       return;
   }

   // Check for enough money

   double price = (type == POSITION_TYPE_BUY)? m_symbol.Ask() : m_symbol.Bid();
   double tp_price = 0;
   double sl_price = 0;
   
   // Calculate Initial Prices
   if(type == POSITION_TYPE_BUY) {
      if(TP_Type == TP_INDIVIDUAL) tp_price = price + TakeProfit * m_symbol.Point();
      else if(tp_price == 0) tp_price = price + TakeProfit * m_symbol.Point();
      if(UseStopLoss) sl_price = price - FixedStopLoss * m_symbol.Point();
   } else {
      if(TP_Type == TP_INDIVIDUAL) tp_price = price - TakeProfit * m_symbol.Point();
      else if(tp_price == 0) tp_price = price - TakeProfit * m_symbol.Point();
      if(UseStopLoss) sl_price = price + FixedStopLoss * m_symbol.Point();
   }

   // Strict Validation: Adjust SL/TP to comply with StopLevel
   AdjustToStopLevel(type, price, sl_price, tp_price);

   sl_price = NormalizeDouble(sl_price, m_symbol.Digits());
   // 2. Money Management Guard
   if(!CheckMoneyForTrade(lot, type)) return;

   m_last_request_tick = GetTickCount64(); // Update immediately to lock threads
   price = (type == POSITION_TYPE_BUY) ? m_symbol.Ask() : m_symbol.Bid();

   if(type == POSITION_TYPE_BUY) {
      string comment = StringFormat("%s BUY #1 (%.2f)", StrategyTag, lot);
      if(m_trade.Buy(lot, Symbol(), price, 0, 0, comment)) { // Use tp=0 for Netting safety
         m_buy_count = 1;
         m_last_buy_price = price;
         if(MQLInfoInteger(MQL_TESTER)) Sleep(100); 
      }
   } else {
      string comment = StringFormat("%s SELL #1 (%.2f)", StrategyTag, lot);
      if(m_trade.Sell(lot, Symbol(), price, 0, 0, comment)) { // Use tp=0 for Netting safety
         m_sell_count = 1;
         m_last_sell_price = price;
         if(MQLInfoInteger(MQL_TESTER)) Sleep(100);
      }
   }
}

//+------------------------------------------------------------------+
//| Check Grid Expansion |
//+------------------------------------------------------------------+
void CheckGridExpansion(ENUM_POSITION_TYPE type, int current_count)
{
   // Use persistent tracking to avoid Netting Loop
   double worst_price = (type == POSITION_TYPE_BUY) ? m_last_buy_price : m_last_sell_price;
   if(worst_price == 0) return; // Should not happen if count > 0
   
   // Calculate Required Distance
   double required_dist = GridDistance;
   if(current_count >= IncreaseDistAfter) {
      required_dist += AddToDistance;
   }
   
   // Check Distance
   bool trigger = false;
   if(type == POSITION_TYPE_BUY) {
      if(m_symbol.Ask() <= worst_price - required_dist * m_symbol.Point()) trigger = true;
   } else {
      if(m_symbol.Bid() >= worst_price + required_dist * m_symbol.Point()) trigger = true;
   }
   
   if(trigger) {
      double price = (type == POSITION_TYPE_BUY)? m_symbol.Ask() : m_symbol.Bid();
      
      if(!IsWithinRange(type, price)) return;
      if(!CheckTradeAllowed()) return;
      if(UseNettingThrottle && GetTickCount64() - m_last_request_tick < 2000) return;
      
      m_last_request_tick = GetTickCount64(); // Lock immediately

      double lot = NormalizeLot(GetLotSize(current_count));
      
      // 1. Guardrail: Volume Check
      string vol_err = "";
      if(!CheckVolumeValue(lot, vol_err)) {
          Print("Validation Error: Invalid Volume: ", vol_err);
          return;
      }

      // Check for enough money

      if(!CheckMoneyForTrade(lot, type)) return;

      double tp = 0;
      double sl = 0;

      // Calculate Initial Prices
      if(type == POSITION_TYPE_BUY) {
         if(TP_Type == TP_INDIVIDUAL) tp = price + TakeProfit * m_symbol.Point();
         else if(tp == 0) tp = price + TakeProfit * m_symbol.Point();
         if(UseStopLoss) sl = price - FixedStopLoss * m_symbol.Point();
      } else {
         if(TP_Type == TP_INDIVIDUAL) tp = price - TakeProfit * m_symbol.Point();
         else if(tp == 0) tp = price - TakeProfit * m_symbol.Point();
         if(UseStopLoss) sl = price + FixedStopLoss * m_symbol.Point();
      }

      // Strict Validation: Adjust SL/TP
      AdjustToStopLevel(type, price, sl, tp);

      sl = NormalizeDouble(sl, m_symbol.Digits());
      tp = NormalizeDouble(tp, m_symbol.Digits());

      string typeStr = (type == POSITION_TYPE_BUY) ? "BUY" : "SELL";
      string comment = StringFormat("%s %s #%d (%.2f)", StrategyTag, typeStr, current_count + 1, lot);

      // Important: For Netting accounts, don't set TP/SL in the market order request.
      // CTrade's modification can fail if the deal is fast, causing the 32,000 trade loop.
      if(type == POSITION_TYPE_BUY) {
         if(m_trade.Buy(lot, Symbol(), price, 0, 0, comment)) {
            m_buy_count++;
            m_last_buy_price = price;
            if(MQLInfoInteger(MQL_TESTER)) Sleep(100);
         }
      } else {
         if(m_trade.Sell(lot, Symbol(), price, 0, 0, comment)) {
            m_sell_count++;
            m_last_sell_price = price;
            if(MQLInfoInteger(MQL_TESTER)) Sleep(100);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Update Average Take Profit |
//+------------------------------------------------------------------+
void UpdateAverageTP(ENUM_POSITION_TYPE type)
{
   double sum_prod = 0;
   double sum_vol = 0;
   
   // Calculate Weighted Average
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
      if(m_position.SelectByIndex(i)) {
         if(IsMyPosition() && m_position.PositionType() == type) {
            sum_prod += m_position.PriceOpen() * m_position.Volume();
            sum_vol += m_position.Volume();
         }
      }
   }
   
   if(sum_vol == 0) return;
   
   // 0. Throttle modifications to prevent log spam (5 seconds)
   if(UseNettingThrottle && GetTickCount64() - m_last_modify_tick < 5000) return;
    
   double avg_price = sum_prod / sum_vol;
   double new_tp = 0;
   
   if(type == POSITION_TYPE_BUY) new_tp = avg_price + TakeProfit * m_symbol.Point();
   else new_tp = avg_price - TakeProfit * m_symbol.Point();
      new_tp = NormalizeDouble(new_tp, m_symbol.Digits());
    
    // Safety: Position Modify must respect Freeze Level
    // Use 2x Buffer for Netting accounts to avoid "Close to Market" rejections
     double freeze_buffer = (double)MathMax(SymbolInfoInteger(Symbol(), SYMBOL_TRADE_FREEZE_LEVEL), 
                                    SymbolInfoInteger(Symbol(), SYMBOL_TRADE_STOPS_LEVEL)) + 20.0;
    double freeze = freeze_buffer * m_symbol.Point();
    double current_price = (type == POSITION_TYPE_BUY) ? m_symbol.Bid() : m_symbol.Ask();

    // Apply to all positions
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
       if(m_position.SelectByIndex(i)) {
          if(IsMyPosition() && m_position.PositionType() == type) {
             
             // 1. DIRECTIONAL VALIDITY (Crucial for XAUUSD Drawdown)
             // For BUY: TP must be ABOVE Bid. If Bid > new_tp, modification will fail.
             if(type == POSITION_TYPE_BUY) {
                if(current_price >= new_tp - m_symbol.Point()) continue; 
             } else {
                if(current_price <= new_tp + m_symbol.Point()) continue;
             }

             // 2. FREEZE LEVEL VALIDITY
             double dist_tp = MathAbs(current_price - new_tp);
             if(dist_tp < freeze) continue; 

             // 3. ACTUAL CHANGE CHECK
             // Only modify if move is > 2 points. If in tester, only log once/hour to save space.
             if(MathAbs(m_position.TakeProfit() - new_tp) > m_symbol.Point() * 2) {
                if(m_trade.PositionModify(m_position.Ticket(), m_position.StopLoss(), new_tp)) {
                   m_last_modify_tick = GetTickCount64();
                   
                   static datetime last_tp_print = 0;
                   if(TimeCurrent() - last_tp_print > 3600) {
                      PrintFormat("Average TP Set: %s #%I64u to %.2f", (type==POSITION_TYPE_BUY?"BUY":"SELL"), m_position.Ticket(), new_tp);
                      last_tp_print = TimeCurrent();
                   }
                }
             }
          }
       }
    }
}

//+------------------------------------------------------------------+
//| Manage Trailing Stop |
//+------------------------------------------------------------------+
void ManageTrailing()
{
   // 1. Calculate Floating Profit per direction
   double profit_buy = 0, profit_sell = 0;
   
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
       if(m_position.SelectByIndex(i) && IsMyPosition()) {
           if(m_position.PositionType() == POSITION_TYPE_BUY) profit_buy += m_position.Profit() + m_position.Swap() + m_position.Commission();
           if(m_position.PositionType() == POSITION_TYPE_SELL) profit_sell += m_position.Profit() + m_position.Swap() + m_position.Commission();
       }
   }
   
   // 2. Identify Last Ticket (if LastTradeTrailing enabled)
   ulong last_buy_ticket = 0;
   ulong last_sell_ticket = 0;
   if(TrailOnlyLast) {
       last_buy_ticket = GetLastTicket(POSITION_TYPE_BUY);
       last_sell_ticket = GetLastTicket(POSITION_TYPE_SELL);
   }

   // 3. Apply Trailing
   // Logic: If Basket Profit > ProfitInAmountTrailStart, apply Points Trailing to valid orders
   
   if(profit_buy >= ProfitToStartTrail) ApplyTrail(POSITION_TYPE_BUY, last_buy_ticket);
   if(profit_sell >= ProfitToStartTrail) ApplyTrail(POSITION_TYPE_SELL, last_sell_ticket);
}

void ApplyTrail(ENUM_POSITION_TYPE type, ulong last_ticket)
{
    double point = m_symbol.Point();
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
       if(m_position.SelectByIndex(i) && IsMyPosition() && m_position.PositionType() == type) {
           
           if(TrailOnlyLast && m_position.Ticket()!= last_ticket) continue;
           
           double new_sl = 0;
           double price = (type == POSITION_TYPE_BUY)? m_symbol.Bid() : m_symbol.Ask();
           
           if(type == POSITION_TYPE_BUY) {
               // Price must be above Open + StartTrailing
               if(price > m_position.PriceOpen() + TrailStartPoints * point) {
                   double proposed = price - TrailStepPoints * point;
                   if(proposed > m_position.PriceOpen() && proposed > m_position.StopLoss()) new_sl = proposed;
               }
           } else {
               if(price < m_position.PriceOpen() - TrailStartPoints * point) {
                   double proposed = price + TrailStepPoints * point;
                   if(proposed < m_position.PriceOpen() && (m_position.StopLoss() == 0 || proposed < m_position.StopLoss())) new_sl = proposed;
               }
           }
           
           if(new_sl!= 0) {
               new_sl = NormalizeDouble(new_sl, m_symbol.Digits());
               m_trade.PositionModify(m_position.Ticket(), new_sl, m_position.TakeProfit());
           }
       }
    }
}


//+------------------------------------------------------------------+
//| License Check                                                    |
//+------------------------------------------------------------------+
bool CheckLicense() {
   // Allow in Strategy Tester
   if(MQLInfoInteger(MQL_TESTER)) return true;
   
   long acc = m_account.Login();
   if(acc == 0) acc = AccountInfoInteger(ACCOUNT_LOGIN);
   
   // 1. Check for Demo Key (Universal)
   if(AccountInfoInteger(ACCOUNT_TRADE_MODE) == ACCOUNT_TRADE_MODE_DEMO) {
      if(LicenseKey == "GSP-DEMO") return true; 
   }
   
   // 2. Check for Real Account Key "GSP-" + AccountID
   string expected_key = "GSP-" + IntegerToString(acc);
   if(LicenseKey == expected_key) return true;
   
   return false;
}

//+------------------------------------------------------------------+
//| Safety Check & Helpers |
//+------------------------------------------------------------------+
void CheckEquityProtection()
{
   double current_dd = m_account.Balance() - m_account.Equity();
   if(current_dd > MaxDDToHedge) {
       if(!m_dd_breached) PrintFormat("Max Drawdown Reached! Current DD: %.2f", current_dd);
       
       if(CloseOnMaxDD) {
          Print("Emergency Protection: Closing ALL Positions.");
          CloseAll();
       }
       m_dd_breached = true;
   } else {
       m_dd_breached = false; 
   }
}

//+------------------------------------------------------------------+
//| Helpers |
//+------------------------------------------------------------------+
double NormalizeLot(double lot) 
{
   double min_lot = m_symbol.LotsMin();
   double max_lot = m_symbol.LotsMax();
   double step_lot = m_symbol.LotsStep();
   
   if(step_lot <= 0) return lot; // Safety fallback
   
   // 1. Round to nearest step
   double steps = MathRound(lot / step_lot);
   double norm_lot = steps * step_lot;
   
   // 2. Clamp to Min/Max
   if(norm_lot < min_lot) norm_lot = min_lot;
   if(norm_lot > max_lot) norm_lot = max_lot;
   
   return normalize_volume(norm_lot); // Using standard lib or simple normalization
}

double normalize_volume(double v) { 
   return NormalizeDouble(v, 2); 
}

// Ensure SL and TP are far enough from price
void AdjustToStopLevel(ENUM_POSITION_TYPE type, double entry_price, double &sl, double &tp) {
   int stop_level = (int)SymbolInfoInteger(Symbol(), SYMBOL_TRADE_STOPS_LEVEL);
   int freeze_level = (int)SymbolInfoInteger(Symbol(), SYMBOL_TRADE_FREEZE_LEVEL);
   int spread = (int)SymbolInfoInteger(Symbol(), SYMBOL_SPREAD);
   
   // Safety Buffer: StopLevel + Spread + 10 points
   double min_dist = (MathMax(stop_level, freeze_level) + spread + 10) * m_symbol.Point();
   
   if(type == POSITION_TYPE_BUY) {
      // SL must be < Bid - min_dist
      if(sl != 0 && (entry_price - sl) < min_dist) {
          sl = entry_price - min_dist; 
          // Print("Validation Adjusted BUY SL");
      }
      // TP must be > Bid + min_dist
      if(tp != 0 && (tp - entry_price) < min_dist) {
          tp = entry_price + min_dist;
          // Print("Validation Adjusted BUY TP");
      }
   } else {
      // SL must be > Ask + min_dist
      if(sl != 0 && (sl - entry_price) < min_dist) {
          sl = entry_price + min_dist;
          // Print("Validation Adjusted SELL SL");
      }
      // TP must be < Ask - min_dist
      if(tp != 0 && (entry_price - tp) < min_dist) {
          tp = entry_price - min_dist;
          // Print("Validation Adjusted SELL TP");
      }
   }
}


bool CheckMoneyForTrade(double lot, ENUM_POSITION_TYPE type)
{
   double margin = 0;
   ENUM_ORDER_TYPE order_type = (type == POSITION_TYPE_BUY) ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
   
   if(!OrderCalcMargin(order_type, _Symbol, lot, m_symbol.Ask(), margin)) return false;
   
   if(!OrderCalcMargin(order_type, _Symbol, lot, m_symbol.Ask(), margin)) return false;
   
   // Validation Safety: Require Margin Buffer
   if(UseMarginBuffer) {
      if(margin * MarginBufferMultiplier > m_account.FreeMargin()) {
         PrintFormat("MARGIN SAFETY: Lot %.2f requires %.2f margin (Safety %.1fx Required), Free: %.2f", lot, margin, MarginBufferMultiplier, m_account.FreeMargin());
         return false;
      }
   }
   
   // Margin Level Safety (Avoid Opening if Margin Level < StopLevel)
   if(UseLowMarginStop) {
      if(m_account.MarginLevel() > 0 && m_account.MarginLevel() < LowMarginLevelStop) {
          PrintFormat("CRITICAL: Margin Level Too Low (%.2f%% < %.2f%%). Skipping Trade.", m_account.MarginLevel(), LowMarginLevelStop);
          return false;
      }
   }
   
   return true;
}

bool CheckTradeAllowed() {
    if(!TerminalInfoInteger(TERMINAL_TRADE_ALLOWED)) return false;
    if(!MQLInfoInteger(MQL_TRADE_ALLOWED)) return false;
    if(!AccountInfoInteger(ACCOUNT_TRADE_ALLOWED)) return false;
    if(!AccountInfoInteger(ACCOUNT_TRADE_EXPERT)) return false;
    return true;
}

bool IsMyPosition() {
   if(m_position.Symbol()!= Symbol()) return false;
   if(m_position.Magic() == MagicNumber) return true;
   if(IncludeManualTrade && m_position.Magic() == 0) return true;
   return false;
}

//+------------------------------------------------------------------+
//| VALIDATION GUARDRAILS (From MQL5 Market Requirements)            |
//+------------------------------------------------------------------+

// 1. Check if Volume is Valid (Min, Max, Step)
bool CheckVolumeValue(double volume, string &description) {
   double min_volume = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MIN);
   double max_volume = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_MAX);
   double volume_step = SymbolInfoDouble(Symbol(), SYMBOL_VOLUME_STEP);

   if(volume < min_volume) {
      description = StringFormat("Volume %.2f < Min %.2f", volume, min_volume);
      return false;
   }
   if(volume > max_volume) {
      description = StringFormat("Volume %.2f > Max %.2f", volume, max_volume);
      return false;
   }
   
   // Check Step
   if(volume_step > 0) {
      int ratio = (int)MathRound(volume / volume_step);
      if(MathAbs(ratio * volume_step - volume) > 0.0000001) {
          description = "Volume not Step Aligned";
          return false;
      }
   }
   
   return true;
}

// 2. Limit Pending Orders (Not used much here, but good for completeness)
bool IsNewOrderAllowed() {
   int max_allowed_orders = (int)AccountInfoInteger(ACCOUNT_LIMIT_ORDERS);
   if(max_allowed_orders == 0) return true; // No limit
   return (OrdersTotal() < max_allowed_orders);
}

// 3. Limit Lots by Symbol
double NewOrderAllowedVolume(string symbol) {
   double symbol_max_volume = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MAX);
   double max_volume_limit = SymbolInfoDouble(symbol, SYMBOL_VOLUME_LIMIT); // Account limit per symbol
   
   if(max_volume_limit == 0) return symbol_max_volume; // No limit
   
   // Calculate open volume
   double opened_volume = 0;
   int total = PositionsTotal();
   for(int i=0; i<total; i++) {
      if(m_position.SelectByIndex(i) && m_position.Symbol() == symbol) {
         opened_volume += m_position.Volume();
      }
   }
   // Add pending orders if any (we don't use them, but good practice)
   
   double allowed = max_volume_limit - opened_volume;
   if(allowed < 0) allowed = 0;
   
   return MathMin(allowed, symbol_max_volume);
}


int CountPositions(ENUM_POSITION_TYPE type) {
   int cnt = 0;
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
      if(m_position.SelectByIndex(i) && IsMyPosition() && m_position.PositionType() == type) cnt++;
   }
   return cnt;
}

bool IsWithinRange(ENUM_POSITION_TYPE type, double price)
{
   if(type == POSITION_TYPE_BUY && UseBuyRange) {
      // For Buy: Start is usually lower, Stop is upper.
      // But we just check if price is between min and max for simplicity
      double min_p = MathMin(BuyStartPrice, BuyStopPrice);
      double max_p = MathMax(BuyStartPrice, BuyStopPrice);
      if(price < min_p || price > max_p) return false;
   }
   
   if(type == POSITION_TYPE_SELL && UseSellRange) {
      double min_p = MathMin(SellStartPrice, SellStopPrice);
      double max_p = MathMax(SellStartPrice, SellStopPrice);
      if(price < min_p || price > max_p) return false;
   }
   
   return true;
}

void UpdateDashboard() {
   if(!ShowDashboard) {
      CleanDashboard();
      return;
   }

   string prefix = "GSP_HUD_";
   
   // --- Position Logic ---
   // Check/Init Globals
   if(g_dash_x == -1) { g_dash_x = DashX; g_dash_y = DashY; }
   
   // Check current position of BG (if user moved it)
   if(ObjectFind(0, prefix+"BG") >= 0) {
      g_dash_x = (int)ObjectGetInteger(0, prefix+"BG", OBJPROP_XDISTANCE);
      g_dash_y = (int)ObjectGetInteger(0, prefix+"BG", OBJPROP_YDISTANCE);
   }

   int x_base = g_dash_x;
   int y_base = g_dash_y;
   int x_label = x_base + 12;      
   int y_row = y_base + 45;        
   int y_step = 26;                // Standardized equal spacing
   
   // Calculate Stats
   double pBuy = 0, pSell = 0, volBuy = 0, volSell = 0;
   int cBuy = CountPositions(POSITION_TYPE_BUY);
   int cSell = CountPositions(POSITION_TYPE_SELL);
   
   for(int i = PositionsTotal() - 1; i >= 0; i--) {
       if(m_position.SelectByIndex(i) && IsMyPosition()) {
           double profit = m_position.Profit() + m_position.Swap() + m_position.Commission();
           if(m_position.PositionType()==POSITION_TYPE_BUY) { pBuy += profit; volBuy += m_position.Volume(); }
           else { pSell += profit; volSell += m_position.Volume(); }
       }
   }
   
   double total_profit = pBuy + pSell;
   double equity = m_account.Equity();
   double balance = m_account.Balance();
   double dd_val = (balance > equity) ? (balance - equity) : 0;
   double dd_pct = (balance > 0) ? (dd_val / balance * 100.0) : 0;

   // --- Theme Logic ---
   color bg_color = C'15,15,15';    // Deeper matte black
   color hdr_color = C'30,30,30';   // Header bar
   color text_main = clrWhite;
   color text_dim = clrSilver;
   
   if(AutoTheme) {
      color chart_bg = (color)ChartGetInteger(0, CHART_COLOR_BACKGROUND);
      if(chart_bg == clrWhite || chart_bg == clrLightGray || chart_bg == clrSilver) {
         bg_color = C'245,245,245';
         hdr_color = C'220,220,220';
         text_main = clrBlack;
         text_dim = clrDarkGray;
      }
   }

   // --- Main Windows ---
   CreateRectLabel(prefix+"BG", x_base, y_base, DashWidth, DashHeight, bg_color, DashColor, 200);
   CreateRectLabel(prefix+"HDR", x_base, y_base, DashWidth, 32, hdr_color, DashColor, 255); 

   // --- Financial Monitoring Header ---
   string tag_upper = StrategyTag;
   StringToUpper(tag_upper);
   string title_text = StringFormat("%s SCALPER", tag_upper);
   CreateLabel(prefix+"Title", title_text, x_base + 10, y_base + 8, DashColor, 9, true); 
   
   // --- Data Rows ---
   string login_str = (m_account.Login() > 0) ? IntegerToString(m_account.Login()) : IntegerToString(AccountInfoInteger(ACCOUNT_LOGIN));
   CreateLabel(prefix+"Acc", StringFormat("TERMINAL ID: %s (%s)", login_str, (AccountInfoInteger(ACCOUNT_TRADE_MODE)==ACCOUNT_TRADE_MODE_DEMO?"DEMO":"LIVE")), x_label, y_row, text_dim, 9);
   y_row += y_step;
   
   CreateLabel(prefix+"Equity", StringFormat("EQUITY: $%.2f", equity), x_label, y_row, text_main, 9);
   y_row += y_step;

   CreateLabel(prefix+"DD", StringFormat("DRAWDOWN: $%.2f (%0.2f%%)", dd_val, dd_pct), x_label, y_row, (dd_pct > 3 ? clrOrange : text_main), 9);
   y_row += y_step;

   CreateLabel(prefix+"Prof", StringFormat("NET PROFIT: $%.2f", total_profit), x_label, y_row, (total_profit >= 0 ? clrLime : clrRed), 9, true);
   y_row += y_step;

   // --- Lower Stats Bar ---
   CreateRectLabel(prefix+"FTR", x_label-2, y_row - 4, DashWidth-20, 1, text_dim, text_dim, 100); 
   y_row += 12; // Small padding before stats
   
   CreateLabel(prefix+"Stats", StringFormat("BUY: %d (%.2fL) | SELL: %d (%.2fL)", cBuy, volBuy, cSell, volSell), x_label, y_row, (AutoTheme && text_main == clrBlack ? clrBlue : clrSkyBlue), 9);
   y_row += y_step;

   if(m_dd_breached) {
      CreateLabel(prefix+"Warn", "CRITICAL PROTECTION ACTIVE", x_base + (DashWidth/2), y_base + DashHeight - 15, clrRed, 9, true, ANCHOR_LOWER);
   }

   ChartRedraw();
}

void CreateLabel(string name, string text, int x, int y, color c, int size=9, bool bold=false, ENUM_ANCHOR_POINT anchor=ANCHOR_LEFT_UPPER) {
    if(ObjectFind(0, name) < 0) {
        ObjectCreate(0, name, OBJ_LABEL, 0, 0, 0);
        ObjectSetInteger(0, name, OBJPROP_CORNER, DashCorner);
        ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
        ObjectSetInteger(0, name, OBJPROP_BACK, false);
    }
    // Always update these properties
    ObjectSetString(0, name, OBJPROP_TEXT, text);
    ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, name, OBJPROP_COLOR, c);
    ObjectSetInteger(0, name, OBJPROP_FONTSIZE, size);
    ObjectSetString(0, name, OBJPROP_FONT, bold ? "Verdana Bold" : "Verdana");
    ObjectSetInteger(0, name, OBJPROP_ANCHOR, anchor);
}

void CreateRectLabel(string name, int x, int y, int w, int h, color bg, color border, int opacity) {
    if(ObjectFind(0, name) < 0) {
        ObjectCreate(0, name, OBJ_RECTANGLE_LABEL, 0, 0, 0);
        ObjectSetInteger(0, name, OBJPROP_CORNER, DashCorner);
        ObjectSetInteger(0, name, OBJPROP_BORDER_TYPE, BORDER_FLAT);
        ObjectSetInteger(0, name, OBJPROP_SELECTABLE, (name == "GSP_HUD_BG"));
        ObjectSetInteger(0, name, OBJPROP_BACK, false);
    } 
    // Always update visual properties for moving/resizing
    ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, name, OBJPROP_XSIZE, w);
    ObjectSetInteger(0, name, OBJPROP_YSIZE, h);
    ObjectSetInteger(0, name, OBJPROP_BGCOLOR, bg);
    ObjectSetInteger(0, name, OBJPROP_COLOR, border);
}


void CleanDashboard() {
    ObjectsDeleteAll(0, "GSP_HUD_");
    Comment("");
}

double GetLotSize(int index) {
   // 1. Get Base Lot from Sequence
   double raw_lot = 0.01;
   int array_size = ArraySize(m_lot_array);
   if(array_size > 0) {
      int safe_idx = (index >= array_size) ? array_size - 1 : index;
      raw_lot = m_lot_array[safe_idx];
   }
   
   if(!UseAutoRisk) return raw_lot;
   
   // --- 2. UNIVERSAL DYNAMIC RISK GUARD (UDRG) ---
   double eq = m_account.Equity();
   if(eq <= 0) return m_symbol.LotsMin();
   
   // 2.1 Calculate Margin Requirement for 1.0 Lot
   double margin_1 = 0;
   if(!OrderCalcMargin(ORDER_TYPE_BUY, Symbol(), 1.0, m_symbol.Ask(), margin_1) || margin_1 <= 0) {
       return m_symbol.LotsMin();
   }

   // 2.2 Equity-to-Margin Hard Cap (Max RiskPercent of equity)
   // This automatically handles expensive symbols like XAUUSD, BTC, etc.
   double max_margin_allowed = eq * (RiskPercent / 100.0); 
   double equity_cap_lot = max_margin_allowed / margin_1;
   
   // 2.3 Predictive Margin Level Scaling
   double limit_margin_total = 0.0;
   
   if(UseLowMarginStop) {
       // Ensure total level > LowMarginLevelStop
       // Formula: Equity / (StopLevel / 100)
       // Example: 500% -> 5.0. Equity / 5.0 = Margin required to stay above 500%
       double divisor = LowMarginLevelStop / 100.0;
       if(divisor <= 0) divisor = 1.0; 
       limit_margin_total = eq / divisor; 
   } else {
       // If safety disabled, allow up to 100% margin level (Equity / 1.0)
       limit_margin_total = eq;
   }
   double cur_margin = m_account.Margin();
   double margin_room = limit_margin_total - cur_margin;
   
   double predictive_max_lot = (margin_room > 0) ? (margin_room / margin_1) : 0;
   
   // Final Safe Lot (Smallest of all safety checks)
   double final_lot = raw_lot;
   final_lot = MathMin(final_lot, equity_cap_lot);
   final_lot = MathMin(final_lot, predictive_max_lot);

   // 3. Absolute Min/Max Clamping
   if(final_lot < m_symbol.LotsMin()) final_lot = m_symbol.LotsMin();
   if(final_lot > m_symbol.LotsMax()) final_lot = m_symbol.LotsMax();

   // Extra: Volume Limit Check
   double max_sym_vol = NewOrderAllowedVolume(Symbol());
   if(final_lot > max_sym_vol) final_lot = max_sym_vol;

   return final_lot;
}



bool ParseLotString(string str_in, double& result[]) {
   string sep = ",";
   ushort u_sep = StringGetCharacter(sep, 0);
   string parts[];
   int total = StringSplit(str_in, u_sep, parts);
   if(total <= 0) return false;
   ArrayResize(result, total);
   for(int i=0; i<total; i++) result[i] = StringToDouble(parts[i]);
   return true;
}

bool RefreshRates() { return m_symbol.RefreshRates(); }

bool IsTradingTime() {
   if(!ApplyTimeFilter) return true;
   MqlDateTime dt;
   TimeToStruct(TimeCurrent(), dt);
   string curr = StringFormat("%02d:%02d", dt.hour, dt.min);
   if(StartTime < StopTime) return (curr >= StartTime && curr <= StopTime);
   return (curr >= StartTime || curr <= StopTime);
}

ulong GetLastTicket(ENUM_POSITION_TYPE type) {
    ulong ticket = 0;
    long time = 0;
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        if(m_position.SelectByIndex(i) && IsMyPosition() && m_position.PositionType() == type) {
            if(m_position.Time() > time) {
                time = m_position.Time();
                ticket = m_position.Ticket();
            }
        }
    }
    return ticket;
}

void CloseAll() {
    for(int i = PositionsTotal() - 1; i >= 0; i--) {
        if(m_position.SelectByIndex(i) && IsMyPosition()) m_trade.PositionClose(m_position.Ticket());
    }
    m_last_close_time = TimeCurrent();
}
//+------------------------------------------------------------------+